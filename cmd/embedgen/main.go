// Package main provides a tool to generate embed.go files for PIGO8 games
package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
)

func main() {
	// Parse command line flags
	var outputDir string
	flag.StringVar(&outputDir, "dir", ".", "Directory where the embed.go file will be created")
	flag.BoolVar(&verbose, "verbose", false, "Enable verbose output")
	flag.Parse()

	// Check if map.json, spritesheet.json, and palette.hex exist in the current directory
	mapPath := filepath.Join(outputDir, "map.json")
	spritesheetPath := filepath.Join(outputDir, "spritesheet.json")
	palettePath := filepath.Join(outputDir, "palette.hex")

	mapExists := fileExists(mapPath)
	spritesheetExists := fileExists(spritesheetPath)
	paletteExists := fileExists(palettePath)

	// Find all music*.wav files
	audioFiles := []string{}

	// Find music*.wav files
	musicWavFiles, err := filepath.Glob(filepath.Join(outputDir, "music*.wav"))
	if err != nil {
		fmt.Printf("Error searching for music*.wav files: %v\n", err)
		os.Exit(1)
	}
	audioFiles = append(audioFiles, musicWavFiles...)
	// If no music files found with wildcards, try to find them individually
	if len(audioFiles) == 0 {
		// Try specific music files that might exist
		for i := 0; i <= 63; i++ { // Check for music0.wav through music63.wav
			specificFile := filepath.Join(outputDir, fmt.Sprintf("music%d.wav", i))
			if fileExists(specificFile) {
				audioFiles = append(audioFiles, specificFile)
			}
		}
	}

	// Filter out invalid or silent audio files and convert to relative paths
	var audioRelPaths []string
	for _, file := range audioFiles {
		// Check if the audio file is valid and contains actual audio data
		if !isValidAudioFile(file) {
			// Skip the file - isValidAudioFile already printed the reason
			continue
		}

		relPath, err := filepath.Rel(outputDir, file)
		if err != nil {
			fmt.Printf("Error getting relative path for %s: %v\n", file, err)
			continue
		}

		// isValidAudioFile already printed the inclusion message
		audioRelPaths = append(audioRelPaths, relPath)
	}

	// Log which resources were found
	resourcesFound := false
	if mapExists {
		fmt.Printf("Found map.json\n")
		resourcesFound = true
	}
	if spritesheetExists {
		fmt.Printf("Found spritesheet.json\n")
		resourcesFound = true
	}
	if paletteExists {
		fmt.Printf("Found palette.hex\n")
		resourcesFound = true
	}
	if len(audioRelPaths) > 0 {
		fmt.Printf("Found %d audio files\n", len(audioRelPaths))
		resourcesFound = true
	}

	// If no resources were found, exit
	if !resourcesFound {
		fmt.Printf("Warning: No resources (map.json, spritesheet.json, palette.hex, or audio*.wav) found in %s\n", outputDir)

		// Check if an embed.go file exists and remove it if it does
		embedGoPath := filepath.Join(outputDir, "embed.go")
		if fileExists(embedGoPath) {
			err := os.Remove(embedGoPath)
			if err != nil {
				fmt.Printf("Warning: Failed to remove existing embed.go file: %v\n", err)
			} else {
				fmt.Printf("Removed existing embed.go file as no resources were found\n")
			}
		}

		// Exit with status 0 (success) instead of 1 (failure)
		os.Exit(0)
	}

	// Generate the embed.go file
	content := `// Code generated by PIGO8 embedgen; DO NOT EDIT.

package main

import (
	"embed"
	
	p8 "github.com/drpaneas/pigo8"
)

// Embed the game-specific resources
//
`
	// Only include files that exist
	embedDirective := "//go:embed"
	if mapExists {
		embedDirective += " map.json"
	}
	if spritesheetExists {
		// Always add a space before the filename
		embedDirective += " spritesheet.json"
	}
	if paletteExists {
		// Always add a space before the filename
		embedDirective += " palette.hex"
	}
	// Add all audio files
	for _, audioFile := range audioRelPaths {
		embedDirective += " " + audioFile
	}
	content += embedDirective + "\n"
	content += `var resources embed.FS

func init() {
	// Register the embedded resources with PIGO8
`

	// Add the correct resource registration
	content += "	p8.RegisterEmbeddedResources(resources, "

	// Add spritesheet path
	if spritesheetExists {
		content += `"spritesheet.json"`
	} else {
		content += `""`
	}

	// Add map path
	content += ", "
	if mapExists {
		content += `"map.json"`
	} else {
		content += `""`
	}

	// Add palette.hex and audio files as variadic arguments
	if paletteExists || len(audioRelPaths) > 0 {
		// Add palette.hex if it exists
		if paletteExists {
			content += `, "palette.hex"`
		}

		// Add audio files
		for _, audioFile := range audioRelPaths {
			content += `, "` + audioFile + `"`
		}
	}

	content += ")\n"

	content += `
	// Audio will be automatically initialized if audio files are present
}
`
	// Write the file
	outputPath := filepath.Join(outputDir, "embed.go")
	err = os.WriteFile(outputPath, []byte(content), 0644)
	if err != nil {
		fmt.Printf("Error generating embed.go: %v\n", err)
		os.Exit(1)
	}

	if verbose {
		fmt.Printf("Generated embed.go for PIGO8 resources in %s\n", outputDir)
	}
}

func fileExists(filename string) bool {
	_, err := os.Stat(filename)
	return err == nil
}

// Global variable for verbose output
var verbose bool

// isValidAudioFile checks if a WAV file contains actual audio data
// Returns true if the file is a valid WAV file with non-silent audio content
func isValidAudioFile(filename string) bool {
	// First check if the file exists
	if !fileExists(filename) {
		return false
	}

	// Open the file
	file, err := os.Open(filename)
	if err != nil {
		if verbose {
			fmt.Printf("Error opening file %s: %v\n", filename, err)
		}
		return false
	}
	defer func() {
		if err := file.Close(); err != nil && verbose {
			fmt.Printf("Error closing file %s: %v\n", filename, err)
		}
	}()

	// Read the WAV header (first 44 bytes)
	header := make([]byte, 44)
	_, err = file.Read(header)
	if err != nil {
		if verbose {
			fmt.Printf("Error reading header from %s: %v\n", filename, err)
		}
		return false
	}

	// Check if it's a valid WAV file by looking for the RIFF and WAVE markers
	if string(header[0:4]) != "RIFF" || string(header[8:12]) != "WAVE" {
		if verbose {
			fmt.Printf("File %s is not a valid WAV file (missing RIFF/WAVE markers)\n", filename)
		}
		return false
	}

	// Check if the file has audio data by looking at the data chunk size
	// The data chunk size is at bytes 40-43 in little-endian format
	dataSize := int(header[40]) + int(header[41])<<8 + int(header[42])<<16 + int(header[43])<<24
	if dataSize <= 0 {
		if verbose {
			fmt.Printf("File %s has no audio data (data chunk size is %d)\n", filename, dataSize)
		}
		return false
	}

	// The file seems to be a valid WAV file with audio data
	if verbose {
		fmt.Printf("Including audio file: %s (data size: %d bytes)\n", filename, dataSize)
	}
	return true
}
